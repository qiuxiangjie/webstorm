<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  /*原型链：
   *
   * 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型
   对象的内部指针（__proto__）。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的
   原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数
   的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实
   例与原型的链条。
   * */

  /*  function SuperType() {
   this.property = true;
   }

   SuperType.prototype.getSuperValue = function () {
   return this.property;
   };
   function SubType() {
   this.subproperty = false;
   this.property = '1';
   }

   //继承了SuperType
   SubType.prototype = new SuperType();
   SubType.prototype.getSubValue = function () {
   return this.subproperty;
   };
   var instance = new SubType();
   console.log(instance.getSuperValue()); // true

   instance.subproperty = 0;

   var instance1 = new SubType();
   console.log(instance1.subproperty);*/


  /*组合继承**************************/

  /*  function SuperType(name) {
   this.name = name;
   this.colors = [ "red", "blue", "green" ];
   }
   SuperType.prototype.sayName = function () {
   alert(this.name);
   };
   function SubType(name, age) {
   //继承属性
   SuperType.call(this, name);
   this.age = age;
   }
   //继承方法
   SubType.prototype = new SuperType();
   SubType.prototype.constructor = SubType;
   SubType.prototype.sayAge = function () {
   alert(this.age);
   };
   var instance1 = new SubType("Nicholas", 29);
   instance1.colors.push("black");
   alert(instance1.colors);      //"red,blue,green,black"
   instance1.sayName();          //"Nicholas";
   instance1.sayAge();           //29
   var instance2 = new SubType("Greg", 27);
   alert(instance2.colors);      //"red,blue,green"
   instance2.sayName();          //"Greg";
   instance2.sayAge();*/           //27

  /*
   * 优势：组合继承避免了原型链和借用构造函数的缺陷，
   *      可以让两个不同的SubType实例既分别拥有自己属性——包括colors属性，
   *      又可以使用相同的方法
   *
   *
   * 缺点: 调用两次超类型构造函数,一次是在创建子类型原型的时候，
   *      另一次是在子类型构造函数内部。
   *
   *
   * */


  /*************************寄生组合式继承***************/

  /*
  *
  * 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。
  * 其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，
  * 我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来
  * 继承超类型的原型，然后再将结果指定给子类型的原型。
  *
  * */

  // 原型式继承
  function object(o) {
    function F() {}

    F.prototype = o;
    return new F();
  }

  // 寄生组合式继承的基本模式
  /*
  * 第一步是创建超类型原型的一个副本。
  * 第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。
  * 最后一步，将新创建的对象（即副本）赋值给子类型的原型
  *
  * */
  function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype);     //创建对象
    prototype.constructor = subType;                 //增强对象
    subType.prototype = prototype;                   //指定对象
  }

  // 例子

  function SuperType(name) {
    this.name = name;
    this.colors = [ "red", "blue", "green" ];
  }
  SuperType.prototype.sayName = function () {
    alert(this.name);
  };
  function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
  }
  inheritPrototype(SubType, SuperType);
  SubType.prototype.sayAge = function () {
    alert(this.age);
  };
  let ss = new SubType('xiangge', 18);

  /*
  *
  * 这个例子的高效率体现在它只调用了一次SuperType构造函数，
  * 并且因此避免了在SubType. prototype上面创建不必要的、多余的属性。
  * 与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。
  * 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式
  *
  * */



</script>
</html>